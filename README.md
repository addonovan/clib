
*disclaimer* you really shouldn't use this for any real project. While I try
to make this stuff as nice as I can, in the end I'm doing it for school, and
so it's probably not actually the best to use any of this stuff in a real
application.

# Generic structures


I have some generic structures, which are generated by a TON of macros,
for the love of god.

## Linked List (list.h, list_\<type\>_t)

Currently, only a few types are implemented by default when you include
this header, but more can easily be defined by doing the following:
```c
#define TYPE <type>                    // 1.
#define TYPED_NAME(x) x##_<type_name>  // 2.
#define COPY_VALUE                     // 3.
#include "list_impl.h"
```
1. `<type>` should be the actual c type that you would write, if you popped
and item off of the list, for instance. (`<type> a = list.pop_front( &list );`)
2. `<type_name>` should be the name of the type as it appears in writing, this
helps avoid tricky situations like trying to have a list of `int*`s or perhaps
`pid_t`s (but you don't want the `_t` appearing in the type name).
3. `COPY_VALUE` should be defined if the value should be copied around. A
notable difference would be the `get` method, which will return a `<type>` if
the value is a copy value, but a `const <type>*` otherwise.

There's no need to `#undef` these items, because `list_impl.h` will do it
for you after it's done.

It should be noted that there is no header guard in `list_impl.h`, so that
multiple types of lists can be generated as necessary; however, this comes
with a drawback, that there is no corresponding `list.c` file, so there isn't
a compilation unit for any of these lists.

### Usage
`list.h` supplies three (more) convenience macros for creating new lists:
* `list_t(x)` will expand to the correct list type for the given 
`<type_name>`, x.

* `list(x)` will create, initialize, and evaluate to a new list of the given
`<type_name>`, x, allocated on the stack.

* `list_u(x)` does the same as `list(x)`, but the value is allocated on the
heap (and thus it'll return a `list_t(x)*`).

```c

// linked list with copy values
list_t(int) list = list(int);

for ( int i = 0; i < 10; i++ )
{
  list.fun->enqueue( &list, i );
}

while ( list.size > 0 )
{
  int size = ( int ) list.size - 1;
  int item = list.fun->pop_back( &list );
  printf( "%d == %d\n", size, item );
}

// linked list with non-copy values
list_t(basic_struct_t) list = list(basic_struct_t);

for ( int i = 0; i < 10; i++ )
{
  basic_struct_t* item = malloc( sizeof( basic_struct_t ) );
  basic_struct_init( item, "hello world", i, 5.34 * i );
  list.fun->enqueue( &list, item );
}

while ( list.size > 0 )
{
  basic_struct_t* item = list.fun->pop_back( &list );
  printf( 
    "%d = { %s, %d, %lf }\n",
    list.size,
    item->string,
    *item->int_ptr,
    item->number
  );
  item->fun->destroy( item );
  free( item );
}
```

