
*disclaimer* you really shouldn't use this for any real project. While I try
to make this stuff as nice as I can, in the end I'm doing it for school, and
so it's probably not actually the best to use any of this stuff in a real
application.

# Generic structures


I have some generic structures, which are generated by a TON of macros,
for the love of god, never look at their definition files (anything matching
`/include\/.*_impl\.h/`), unless you want to see macros everywhere.

## Linked List (list.h, list_\<type\>_t)

Currently, only a few types are implemented by default when you include
this header, but more can easily be defined by doing the following:
```c
#define TYPE <type>                    // 1.
#define TYPED_NAME(x) x##_<type_name>  // 2.
#define COPY_VALUE                     // 3.
#include "list_impl.h"
```
1. `<type>` should be the actual c type that you would write, if you popped
and item off of the list, for instance. (`<type> a = list.pop_front( &list );`)
2. `<type_name>` should be the name of the type as it appears in writing, this
helps avoid tricky situations like trying to have a list of `int*`s or perhaps
`pid_t`s (but you don't want the `_t` appearing in the type name).
3. `COPY_VALUE` should be defined if the value should be copied around. A
notable difference would be the `get` method, which will return a `<type>` if
the value is a copy value, but a `const <type>*` otherwise.

There's no need to `#undef` these items, because `list_impl.h` will do it
for you after it's done.

It should be noted that there is no header guard in `list_impl.h`, so that
multiple types of lists can be generated as necessary; however, this comes
with a drawback, that there is no corresponding `list.c` file, so there isn't
a compilation unit for any of these lists.

### Usage
`list.h` supplies three (more) convenience macros for creating new lists:
* `list_t(x)` will expand to the correct list type for the given 
`<type_name>`, x.

* `list(x)` will create, initialize, and evaluate to a new list of the given
`<type_name>`, x, allocated on the stack.

* `list_u(x)` does the same as `list(x)`, but the value is allocated on the
heap (and thus it'll return a `list_t(x)*`).

```c

// stack-allocated linked list

list_t(int) list = list(int);
int i;
for ( i = 0; i < 10; i++ )
{
list.push_back( &list, 5 * i );
}

while ( list.size > 0 )
{
printf( "%d\n", list.pop_back( &list ) );
}

// heap-allocated linked list
list_t(double)* list = list_u(double);

int i;
for ( i = 0; i < 10; i++ )
{
list->push_back( list, 5.0 * ( i + 1.5 ) );
}

while ( list->size > 0 )
{
printf( "%lf\n", list->pop_back( list ) );
}

```

